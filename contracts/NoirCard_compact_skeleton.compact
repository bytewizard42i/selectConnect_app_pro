#pragma version "0.16.0"

// NoirCard (Compact-compliant skeleton)
// This file provides a Compact-style baseline that replaces unsupported constructs
// found in the previous draft (events, Address, context.*, Map/Array, String, etc.).
// It models public metadata in simple Sets and sensitive data as commitments
// stored in a Merkle tree. Business logic is expressed via circuits with asserts
// and ledger mutations.

import Std.Ledger
import Std.Crypto

// -----------------------------
// Public Ledger (minimal)
// -----------------------------
// Note: Owner and Accessor identifiers are represented as Bytes<32> (application-defined),
// not Address. Timestamps are Uint<64> provided as inputs to circuits.

export ledger cards: Set<Bytes<32>>
export ledger card_owner: Set<(Bytes<32>, Bytes<32>)>              // (cardId, ownerId)
export ledger card_policy: Set<(Bytes<32>, Bool, Uint<64>, Uint<64>)> // (cardId, requiresBond, bondAmount, revealDelay)
export ledger link_meta: Set<(Bytes<32>, Bytes<32>, Uint<64>, Uint<64>, Bool, Uint<8>)> // (linkId, cardId, createdAt, expiresAt, revoked, currentLevel)
export ledger reveal_tree: MerkleTree                              // commitments of reveal levels per card scope
export ledger contact_commit: Set<(Bytes<32>, Bytes<32>)>          // (cardId, contactDataCommit)

// -----------------------------
// Helper hashing/commitment notes
// -----------------------------
// Use persistentHash/persistentCommit to derive stable IDs/commitments.
// Application supplies ownerId/accessorCommit/timestamps.

// cardId = persistentHash(ownerId, aliasHash, createdAt)
// contactDataCommit = persistentCommit(contactCiphertext, rand)
// levelCommit[i]    = persistentCommit(levelCiphertext_i, rand_i)
// linkId = persistentHash(cardId, accessorCommit, nonceOrTime)

// -----------------------------
// Circuits
// -----------------------------

export circuit createCard(
  ownerId: Bytes<32>,
  createdAt: Uint<64>,
  aliasHash: Bytes<32>,                    // hash of alias bytes (do not store raw alias)
  requiresBond: Bool,
  bondAmount: Uint<64>,
  revealDelay: Uint<64>,                   // seconds between levels
  contactCiphertext: Bytes<32>,            // opaque ciphertext
  contactRand: Bytes<32>,                  // randomness for commitment
  levelCommits: Set<Bytes<32>>             // commitments for reveal levels (leaves to insert)
) -> Bytes<32> {
  let cardId = persistentHash(ownerId, aliasHash, toBytes32(createdAt))
  assert(!Ledger.contains(cards, cardId), "card already exists")

  // Insert card
  Ledger.insert(cards, cardId)
  Ledger.insert(card_owner, (cardId, ownerId))
  Ledger.insert(card_policy, (cardId, requiresBond, bondAmount, revealDelay))

  // Store contact data commitment
  let contactCommitment = persistentCommit(contactCiphertext, contactRand)
  Ledger.insert(contact_commit, (cardId, contactCommitment))

  // Insert reveal level commitments into reveal_tree
  for c in levelCommits {
    // Optionally namespace by cardId via hashing: node = persistentHash(cardId, c)
    // Here we just insert the commitment; consumers must scope by cardId in proofs.
    Ledger.treeInsert(reveal_tree, c)
  }

  cardId
}

export circuit generateAccessLink(
  cardId: Bytes<32>,
  accessorCommit: Bytes<32>,               // privacy-preserving accessor commitment
  nowTs: Uint<64>,
  ttl: Uint<64>                            // seconds; if 0, treat as immediate expiry policy
) -> Bytes<32> {
  assert(Ledger.contains(cards, cardId), "card not found")
  let expiresAt = nowTs + ttl
  let linkId = persistentHash(cardId, accessorCommit, toBytes32(nowTs))

  Ledger.insert(link_meta, (linkId, cardId, nowTs, expiresAt, false, 0))
  linkId
}

export circuit accessCard(
  linkId: Bytes<32>,
  requestedLevel: Uint<8>,
  nowTs: Uint<64>,
  levelCiphertext: Bytes<32>,
  levelRand: Bytes<32>
) -> Bytes<32> {
  // Load link meta
  let (lId, cId, createdAt, expiresAt, revoked, currentLevel) = Ledger.get(link_meta, linkId)
  assert(lId == linkId, "link not found")
  assert(!revoked, "revoked")
  assert(nowTs < expiresAt, "expired")

  // Progressive: can only advance by +1 per call
  assert(requestedLevel == currentLevel + 1u8 || requestedLevel == currentLevel, "sequential access only")

  // Verify requested level exists via commitment membership
  let levelCommit = persistentCommit(levelCiphertext, levelRand)
  assert(Ledger.treeContains(reveal_tree, levelCommit), "unknown reveal level")

  // Optional delay enforcement can be modeled externally or via additional meta ledgers

  // Update currentLevel if advancing
  if (requestedLevel > currentLevel) {
    Ledger.remove(link_meta, linkId)
    Ledger.insert(link_meta, (linkId, cId, createdAt, expiresAt, revoked, requestedLevel))
  }

  // Return ciphertext (decryption off-chain by authorized recipient)
  levelCiphertext
}

export circuit revokeLink(
  cardId: Bytes<32>,
  ownerId: Bytes<32>,
  linkId: Bytes<32>
) {
  assert(Ledger.contains(card_owner, (cardId, ownerId)), "not owner")
  let (lId, cId, createdAt, expiresAt, _revoked, currentLevel) = Ledger.get(link_meta, linkId)
  assert(lId == linkId && cId == cardId, "link mismatch")

  // Mark revoked by replacing tuple
  Ledger.remove(link_meta, linkId)
  Ledger.insert(link_meta, (linkId, cId, createdAt, expiresAt, true, currentLevel))
}

export circuit updateCard(
  cardId: Bytes<32>,
  ownerId: Bytes<32>,
  newContactCiphertext: Bytes<32>,
  newContactRand: Bytes<32>,
  newLevelCommits: Set<Bytes<32>>
) {
  assert(Ledger.contains(card_owner, (cardId, ownerId)), "not owner")

  // Replace contact commitment
  // Remove old (if present) by scanning is omitted; just insert new tuple which supersedes off-chain
  let newCommit = persistentCommit(newContactCiphertext, newContactRand)
  Ledger.insert(contact_commit, (cardId, newCommit))

  // Insert new level commitments
  for c in newLevelCommits {
    Ledger.treeInsert(reveal_tree, c)
  }
}
