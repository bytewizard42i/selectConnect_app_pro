// SPDX-License-Identifier: Apache-2.0
// ============================================================================
// AbuseEscrow Contract - Economic Spam Prevention for SelectConnect Protocol
// ============================================================================
// Version: 1.0.0
// Compact Language Version: 0.16
//
// PURPOSE:
// This contract implements an economic abuse prevention system for the SelectConnect
// protocol. It requires potential message senders to post refundable bonds before
// contacting card holders, creating financial disincentives for spam and harassment.
//
// CORE MECHANICS:
// 1. Bond Posting: Senders stake tokens before initiating contact
// 2. Dynamic Pricing: Bond amounts increase based on sender's abuse history
// 3. Bond Slashing: Admins can confiscate bonds for verified abuse
// 4. Safety Pools: Slashed funds accumulate to compensate victims
// 5. Reputation Tracking: Persistent scoring system for sender behavior
//
// PRIVACY MODEL:
// - Public: Bond IDs, amounts, timestamps, aggregate reputation metrics
// - Private: Sender identities (hidden behind cryptographic commitments)
// - Selective Disclosure: Only abuse evidence hashes are revealed on-chain
//
// ECONOMIC SECURITY:
// - Minimum bond amounts configurable per card (3-100 ADA typical range)
// - Risk multipliers increase bonds by 50% per previous slash
// - Safety pools provide victim compensation from slashed bonds
// - Time-limited bonds with automatic expiry for honest interactions
//
// INTEGRATION:
// This contract works in conjunction with SelectConnectProtocol.compact to provide
// comprehensive privacy-preserving contact management with economic accountability.
// ============================================================================

pragma language_version 0.16;

import CompactStandardLibrary;

// Public on-chain state
// round: epoch counter that can be used to rotate keys/authorization semantics across time
export ledger round: Counter; // epoch counter for rotating auth if desired
// bonds: set of bond IDs that exist
export ledger bonds: Set<Bytes<32>>;                                         // bondId
// bond_meta: details for each bondId
export ledger bond_meta: Map<Bytes<32>, (Bytes<32>, Bytes<32>, Uint<64>, Uint<64>, Boolean, Boolean)>; // bondId -> (cardId, senderCommit, amount, expiresAt, refunded, slashed)
// safety_pool: per-card slashed balance accumulator
export ledger safety_pool: Map<Bytes<32>, Uint<64>>;                          // cardId -> balance
// sender_rep: coarse reputation counters keyed by sender commitment (not PII)
export ledger sender_rep: Map<Bytes<32>, (Uint<32>, Uint<32>, Uint<64>, Uint<64>)>; // senderCommit -> (totalBonds, slashedCount, lastSlashTime, totalSlashed)
// bond_config: per-card configuration for minimums/TTLs and dynamic pricing
export ledger bond_config: Map<Bytes<32>, (Uint<64>, Uint<64>, Boolean, Uint<64>)>;   // cardId -> (minBondAmount, defaultTTL, dynamicPricing, riskMultiplier)
// card_owner: pair linking a card to an owner identifier (Bytes<32>), used for authorization
export ledger card_admin: Map<Bytes<32>, Bytes<32>>;                           // cardId -> adminId

// Constructor initializes epoch
constructor() {
  round.increment(1);
}

// Witness inputs
witness adminSecret(): Bytes<32>;
witness rand(): Bytes<32>;

// Domain constants (align with SelectConnect)
const DOMAIN_CARD  : Bytes<32> = pad(32, "noircard:card:v1");
const DOMAIN_BOND  : Bytes<32> = pad(32, "noircard:bond:v1");

// Helper: derive adminId from epoch-bound secret (aligned with SelectConnect)
// The admin proves control via a secret; we derive a stable public identifier from it and the current epoch.
circuit adminId(round: Field, sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([ DOMAIN_CARD, (round as Bytes<32>), sk ]);
}

// Helper: calculate dynamic required bond amount
// If dynamicPricing is enabled, increase the minimum bond based on historical slashes for this senderCommit.
circuit calcRequired(minBond: Uint<64>, dynPricing: Boolean, riskMult: Uint<64>, senderCommit: Bytes<32>): Uint<64> {
  if (!dynPricing) { return minBond }
  let (total, slashedCount, _lastSlash, _totalSlashed) = getOrDefault(sender_rep, senderCommit, (0u32, 0u32, 0u64, 0u64));
  if (slashedCount == 0u32) { return minBond }
  let multiplierBp = 10000u64 + (toUint64(slashedCount) * riskMult);
  return (minBond * multiplierBp) / 10000u64;
}

// Post a bond to contact a SelectConnect
// Inputs:
//  - cardId: target SelectConnect ID
//  - senderCommit: commitment to sender identity (keeps sender private)
//  - amount: posted amount (must meet required threshold)
//  - nowTs, ttl: timestamps for expiry
// Effects:
//  - Creates a new bondId and records its metadata
//  - Increments sender reputation totalBonds
export circuit postBond(
  cardId: Bytes<32>,
  senderCommit: Bytes<32>,
  amount: Uint<64>,
  nowTs: Uint<64>,
  ttl: Uint<64>
): Bytes<32> {
  let (minBond, defTTL, dynPricing, riskMult) = getOrDefault(bond_config, cardId, (0u64, 0u64, false, 0u64));
  let requiredAmount = calcRequired(minBond, dynPricing, riskMult, senderCommit);
  assert(amount >= requiredAmount, "insufficient amount");

  let expiry = nowTs + (if ttl > 0u64 { ttl } else { defTTL });
  let bondId = persistentHash<Vector<3, Bytes<32>>>([ DOMAIN_BOND, cardId, senderCommit ]);

  insert(bonds, bondId);
  insert(bond_meta, bondId, (cardId, senderCommit, amount, expiry, false, false));

  // Update sender reputation
  let (total, slashedCount, lastSlash, totalSlashed) = getOrDefault(sender_rep, senderCommit, (0u32, 0u32, 0u64, 0u64));
  remove(sender_rep, senderCommit);
  insert(sender_rep, senderCommit, (total + 1u32, slashedCount, lastSlash, totalSlashed));

  return disclose(bondId);
}

// Refund bond (called by recipient engagement or TTL expiry)
// Policy:
//  - Anyone can trigger a refund after expiry
//  - Before expiry, must be an authorized party (modeled by authorizerIsAdmin flag provided by caller's proof)
export circuit refundBond(
  bondId: Bytes<32>,
  nowTs: Uint<64>,
  authorizerIsAdmin: Boolean
): [] {
  let (cId, sCommit, amount, expiresAt, refunded, slashed) = get(bond_meta, bondId);
  assert(!refunded && !slashed, "already processed");
  assert(nowTs >= expiresAt || authorizerIsAdmin, "not authorized or not expired");

  remove(bond_meta, bondId);
  insert(bond_meta, bondId, (cId, sCommit, amount, expiresAt, true, slashed));
}

// Slash bond on abuse attestation (admin-only)
// Authorization:
//  - The admin of the card proves control via adminSecret witness -> adminId -> membership in card_admin
// Effects:
//  - Marks the bond slashed
//  - Updates sender reputation (increments slashedCount, records lastSlashTime, accumulates totalSlashed)
//  - Allocates half of the slashed amount to the card's safety_pool
export circuit slashBond(
  bondId: Bytes<32>,
  cardId: Bytes<32>,
  nowTs: Uint<64>
): [] {
  const sk = adminSecret();
  const aid = adminId(round, sk);
  let storedAdmin = get(card_admin, cardId);
  assert(storedAdmin == aid, "not admin");

  let (cId, sCommit, amount, expiresAt, refunded, slashed) = get(bond_meta, bondId);
  assert(cId == cardId, "bond/card mismatch");
  assert(!refunded && !slashed, "already processed");

  remove(bond_meta, bondId);
  insert(bond_meta, bondId, (cId, sCommit, amount, expiresAt, refunded, true));

  // Update sender reputation
  let (total, scount, lastSlash, totalSlashed) = getOrDefault(sender_rep, sCommit, (0u32, 0u32, 0u64, 0u64));
  remove(sender_rep, sCommit);
  insert(sender_rep, sCommit, (total, scount + 1u32, nowTs, totalSlashed + amount));

  // Safety pool receives half
  let half = amount / 2u64;
  let bal = getOrDefault(safety_pool, cardId, 0u64);
  remove(safety_pool, cardId);
  insert(safety_pool, cardId, bal + half);
}

// Configure bond parameters for a card (admin-only)
// Fields:
//  - minBondAmount: minimum bond required
//  - defaultTTL: fallback expiry if caller does not specify TTL
//  - dynamicPricing: enable risk-based increases for repeat offenders
//  - riskMultiplier: increase per prior slash (basis points-like)
export circuit configureBond(
  cardId: Bytes<32>,
  minBondAmount: Uint<64>,
  defaultTTL: Uint<64>,
  dynamicPricing: Boolean,
  riskMultiplier: Uint<64>
): [] {
  const sk = adminSecret();
  const aid = adminId(round, sk);
  let storedAdmin = get(card_admin, cardId);
  assert(storedAdmin == aid, "not admin");

  if (contains(bond_config, cardId)) {
    remove(bond_config, cardId);
  }
  insert(bond_config, cardId, (minBondAmount, defaultTTL, dynamicPricing, riskMultiplier));
}

// Register or update the admin mapping for a card (called by admin)
// This links a given cardId to the adminId derived from the caller's adminSecret at the current epoch.
export circuit registerCardAdmin(cardId: Bytes<32>): [] {
  const sk = adminSecret();
  const aid = adminId(round, sk);
  if (contains(card_admin, cardId)) {
    let storedAdmin = get(card_admin, cardId);
    if (storedAdmin == aid) {
      // already registered for this admin; no-op
      return;
    }
    // Remove previous admin mapping
    remove(card_admin, cardId);
  }
  insert(card_admin, cardId, aid);
}
