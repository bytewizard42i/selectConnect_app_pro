// SPDX-License-Identifier: Apache-2.0

pragma language_version 0.16;

import CompactStandardLibrary;

// Public on-chain state
export ledger round: Counter; // epoch counter for rotating auth if desired
export ledger bonds: Set<Bytes<32>>;                                         // bondId
export ledger bond_meta: Set<(Bytes<32>, Bytes<32>, Bytes<32>, Uint<64>, Uint<64>, Bool, Bool)>; // (bondId, cardId, senderCommit, amount, expiresAt, refunded, slashed)
export ledger safety_pool: Set<(Bytes<32>, Uint<64>)>;                        // (cardId, balance)
export ledger sender_rep: Set<(Bytes<32>, Uint<32>, Uint<32>, Uint<64>, Uint<64>)>; // (senderCommit, totalBonds, slashedCount, lastSlashTime, totalSlashed)
export ledger bond_config: Set<(Bytes<32>, Uint<64>, Uint<64>, Bool, Uint<64>)>;     // (cardId, minBondAmount, defaultTTL, dynamicPricing, riskMultiplier)
export ledger card_owner: Set<(Bytes<32>, Bytes<32>)>;                         // (cardId, ownerId)

// Constructor initializes epoch
constructor() {
  round.increment(1);
}

// Witness inputs
witness ownerSecret(): Bytes<32>;
witness rand(): Bytes<32>;

// Helper: derive ownerId from epoch-bound secret
circuit ownerId(round: Field, sk: Bytes<32}): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([ (round as Bytes<32>), sk ]);
}

// Helper: calculate dynamic required bond amount
circuit calcRequired(minBond: Uint<64>, dynPricing: Bool, riskMult: Uint<64>, senderCommit: Bytes<32>): Uint<64> {
  if (!dynPricing) { return minBond }
  let (sc, total, slashedCount, _lastSlash, _totalSlashed) = getOrDefault(sender_rep, senderCommit, (senderCommit, 0u32, 0u32, 0u64, 0u64));
  if (slashedCount == 0u32) { return minBond }
  let multiplierBp = 10000u64 + (toUint64(slashedCount) * riskMult);
  return (minBond * multiplierBp) / 10000u64;
}

// Post a bond to contact a NoirCard
export circuit postBond(
  cardId: Bytes<32>,
  senderCommit: Bytes<32>,
  amount: Uint<64>,
  nowTs: Uint<64>,
  ttl: Uint<64>
): Bytes<32> {
  let (cfgCard, minBond, defTTL, dynPricing, riskMult) = getOrDefault(bond_config, cardId, (cardId, 0u64, 0u64, false, 0u64));
  let requiredAmount = calcRequired(minBond, dynPricing, riskMult, senderCommit);
  assert(amount >= requiredAmount, "insufficient amount");

  let expiry = nowTs + (if ttl > 0u64 { ttl } else { defTTL });
  let bondId = persistentHash<Vector<3, Bytes<32>>>([ cardId, senderCommit, toBytes32(nowTs) ]);

  insert(bonds, bondId);
  insert(bond_meta, (bondId, cardId, senderCommit, amount, expiry, false, false));

  // Update sender reputation
  let (sc, total, slashedCount, lastSlash, totalSlashed) = getOrDefault(sender_rep, senderCommit, (senderCommit, 0u32, 0u32, 0u64, 0u64));
  remove(sender_rep, senderCommit);
  insert(sender_rep, (senderCommit, total + 1u32, slashedCount, lastSlash, totalSlashed));

  return bondId;
}

// Refund bond (called by recipient engagement or TTL expiry)
export circuit refundBond(
  bondId: Bytes<32>,
  nowTs: Uint<64>,
  authorizerIsOwner: Bool
): [] {
  let (bId, cId, sCommit, amount, expiresAt, refunded, slashed) = get(bond_meta, bondId);
  assert(bId == bondId, "not found");
  assert(!refunded && !slashed, "already processed");
  assert(nowTs >= expiresAt || authorizerIsOwner, "not authorized or not expired");

  remove(bond_meta, bondId);
  insert(bond_meta, (bondId, cId, sCommit, amount, expiresAt, true, slashed));
}

// Slash bond on abuse attestation (owner-only)
export circuit slashBond(
  bondId: Bytes<32>,
  cardId: Bytes<32>,
  nowTs: Uint<64>
): [] {
  const sk = ownerSecret();
  const oid = ownerId(round, sk);
  assert(contains(card_owner, (cardId, oid)), "not owner");

  let (bId, cId, sCommit, amount, expiresAt, refunded, slashed) = get(bond_meta, bondId);
  assert(bId == bondId && cId == cardId, "bond/card mismatch");
  assert(!refunded && !slashed, "already processed");

  remove(bond_meta, bondId);
  insert(bond_meta, (bondId, cId, sCommit, amount, expiresAt, refunded, true));

  // Update sender reputation
  let (sc, total, scount, lastSlash, totalSlashed) = getOrDefault(sender_rep, sCommit, (sCommit, 0u32, 0u32, 0u64, 0u64));
  remove(sender_rep, sCommit);
  insert(sender_rep, (sCommit, total, scount + 1u32, nowTs, totalSlashed + amount));

  // Safety pool receives half
  let half = amount / 2u64;
  let (poolCard, bal) = getOrDefault(safety_pool, cardId, (cardId, 0u64));
  remove(safety_pool, cardId);
  insert(safety_pool, (cardId, bal + half));
}

// Configure bond parameters for a card (owner-only)
export circuit configureBond(
  cardId: Bytes<32>,
  minBondAmount: Uint<64>,
  defaultTTL: Uint<64>,
  dynamicPricing: Bool,
  riskMultiplier: Uint<64>
): [] {
  const sk = ownerSecret();
  const oid = ownerId(round, sk);
  assert(contains(card_owner, (cardId, oid)), "not owner");

  if (contains(bond_config, cardId)) {
    remove(bond_config, cardId);
  }
  insert(bond_config, (cardId, minBondAmount, defaultTTL, dynamicPricing, riskMultiplier));
}
