// Compact v0.16.0 - Abuse bond escrow contract
// Compatible with Midnight blockchain
#pragma version "0.16.0"

import Std.Ledger
import Std.Crypto

circuit AbuseEscrow {
    // State variables for contract storage
    state bonds: Map<Bytes32, Bond>;
    state cardConfigs: Map<Bytes32, BondConfig>;
    state reputation: Map<Bytes32, SenderReputation>;
    state safetyPool: Map<Bytes32, U64>;
    // Bond structure with all required fields
    struct Bond {
        amount: U64,           // Bond amount in lovelace
        senderCommit: Bytes32, // H(senderDID || salt) - stable per card
        cardId: Bytes32,       // NoirCard identifier
        expiresAt: U64,        // TTL timestamp
        refunded: Bool,        // Refund status
        slashed: Bool,         // Slash status
        sender: Address,       // Original sender for refunds
        postedAt: U64,         // Timestamp when bond was posted
    }

    // Dynamic bond configuration per card
    struct BondConfig {
        minBondAmount: U64,    // Minimum required bond
        defaultTTL: U64,       // Default expiry time
        dynamicPricing: Bool,  // Enable context-based pricing
        riskMultiplier: U64,   // Risk-based multiplier (basis points)
    }

    // Reputation tracking per sender commitment
    struct SenderReputation {
        totalBonds: U32,       // Total bonds posted
        slashedCount: U32,     // Number of slashed bonds
        lastSlashTime: U64,    // Last time sender was slashed
        totalSlashed: U64,     // Total amount slashed
    }


    // Events
    event BondPosted { bondId: Bytes32, cardId: Bytes32, senderCommit: Bytes32, amount: U64, expiresAt: U64 }
    event BondRefunded { bondId: Bytes32, cardId: Bytes32, senderCommit: Bytes32, amount: U64 }
    event BondSlashed { bondId: Bytes32, cardId: Bytes32, senderCommit: Bytes32, amount: U64, evidenceHash: Bytes32 }
    event AbuseAttested { cardId: Bytes32, senderNull: Bytes32, evidenceHash: Bytes32, timestamp: U64 }
    event SafetyPoolUpdated { cardId: Bytes32, newBalance: U64 }

    // Post a bond to contact a NoirCard
    @public
    fn postBond(
        cardId: Bytes32,
        senderCommit: Bytes32,
        amount: U64,
        ttl: U64
    ) -> Bytes32 {
        // Generate unique bond ID
        let bondId = hash(cardId, senderCommit, context.block_time, context.sender);
        
        // Get bond configuration for this card
        let config = cardConfigs.get(cardId).unwrap_or_default();
        
        // Calculate required bond amount (with dynamic pricing if enabled)
        let requiredAmount = calculateBondAmount(cardId, senderCommit, &config);
        assert!(amount >= requiredAmount, "Insufficient bond amount");
        
        // Check sender doesn't have active bond for this card
        assert!(!hasActiveBond(cardId, senderCommit), "Active bond already exists");
        
        // Create bond
        let bond = Bond {
            amount: amount,
            senderCommit: senderCommit,
            cardId: cardId,
            expiresAt: context.block_time + if ttl > 0 { ttl } else { config.defaultTTL },
            refunded: false,
            slashed: false,
            sender: context.sender,
            postedAt: context.block_time,
        };
        
        bonds.insert(bondId, bond);

        // Update sender reputation
        let mut rep = reputation.get(senderCommit).unwrap_or_default();
        rep.totalBonds += 1;
        reputation.insert(senderCommit, rep);

        emit BondPosted { bondId, cardId, senderCommit, amount, expiresAt: bond.expiresAt };
        bondId
    }

    // Refund bond (called by recipient engagement or TTL expiry)
    @public
    fn refundBond(bondId: Bytes32) {
        let mut bond = bonds.get(bondId).expect("Bond does not exist");
        assert!(!bond.refunded && !bond.slashed, "Bond already processed");
        
        // Check if TTL expired or if called by authorized party
        assert!(
            context.block_time >= bond.expiresAt || 
            isAuthorizedRefunder(bondId, context.sender),
            "Not authorized or not expired"
        );

        bond.refunded = true;
        bonds.insert(bondId, bond);
        
        // Transfer bond back to sender (implementation would handle actual transfer)
        // transfer(bond.sender, bond.amount);
        
        emit BondRefunded { bondId, cardId: bond.cardId, senderCommit: bond.senderCommit, amount: bond.amount };
    }

    // Slash bond on abuse attestation
    @public
    fn slashBond(
        bondId: Bytes32, 
        evidenceHash: Bytes32,
        senderNull: Bytes32
    ) {
        let mut bond = bonds.get(bondId).expect("Bond does not exist");
        assert!(!bond.refunded && !bond.slashed, "Bond already processed");
        assert!(isAuthorizedSlasher(bond.cardId, context.sender), "Not authorized to slash");

        bond.slashed = true;
        bonds.insert(bondId, bond);

        // Update sender reputation
        let mut rep = reputation.get(bond.senderCommit).unwrap_or_default();
        rep.slashedCount += 1;
        rep.lastSlashTime = context.block_time;
        rep.totalSlashed += bond.amount;
        reputation.insert(bond.senderCommit, rep);

        // Split slashed amount: 50% to safety pool, 50% burned
        let safetyAmount = bond.amount / 2;
        let _burnAmount = bond.amount - safetyAmount;

        // Add to safety pool
        let currentPool = safetyPool.get(bond.cardId).unwrap_or(0);
        safetyPool.insert(bond.cardId, currentPool + safetyAmount);
        
        // Burn remaining amount (implementation would handle actual burning)
        // burn(burnAmount);

        emit BondSlashed { bondId, cardId: bond.cardId, senderCommit: bond.senderCommit, amount: bond.amount, evidenceHash };
        emit AbuseAttested { cardId: bond.cardId, senderNull, evidenceHash, timestamp: context.block_time };
        emit SafetyPoolUpdated { cardId: bond.cardId, newBalance: currentPool + safetyAmount };
    }

    // Configure bond parameters for a card
    @public
    fn configureBond(
        cardId: Bytes32,
        minBondAmount: U64,
        defaultTTL: U64,
        dynamicPricing: Bool,
        riskMultiplier: U64
    ) {
        assert!(isCardOwner(cardId, context.sender), "Not card owner");
        
        let config = BondConfig {
            minBondAmount: minBondAmount,
            defaultTTL: defaultTTL,
            dynamicPricing: dynamicPricing,
            riskMultiplier: riskMultiplier,
        };
        
        cardConfigs.insert(cardId, config);
    }

    // Calculate required bond amount with dynamic pricing
    fn calculateBondAmount(
        cardId: Bytes32, 
        senderCommit: Bytes32, 
        config: &BondConfig
    ) -> U64 {
        let mut baseAmount = config.minBondAmount;
        
        if !config.dynamicPricing {
            return baseAmount;
        }

        // Apply reputation-based multiplier
        let rep = reputation.get(senderCommit).unwrap_or_default();
        if rep.slashedCount > 0 {
            // Increase bond for repeat offenders
            let multiplier = 1000 + (rep.slashedCount as U64 * config.riskMultiplier);
            baseAmount = (baseAmount * multiplier) / 1000;
        }

        baseAmount
    }

    // Check if sender has active bond for card
    fn hasActiveBond(cardId: Bytes32, senderCommit: Bytes32) -> Bool {
        // Implementation would check for existing active bonds
        // This is a simplified version
        false
    }

    // Authorization checks
    fn isAuthorizedRefunder(bondId: Bytes32, caller: Address) -> Bool {
        let bond = bonds.get(bondId).expect("Bond not found");
        // Card owner or relay service can authorize refunds
        isCardOwner(bond.cardId, caller) || isRelayService(caller)
    }

    fn isAuthorizedSlasher(cardId: Bytes32, caller: Address) -> Bool {
        // Card owner, guardians, or relay service can slash
        isCardOwner(cardId, caller) || isGuardian(caller) || isRelayService(caller)
    }

    fn isCardOwner(cardId: Bytes32, caller: Address) -> Bool {
        // Implementation would check card ownership
        true // Simplified
    }

    fn isGuardian(caller: Address) -> Bool {
        // Implementation would check guardian status
        true // Simplified
    }

    fn isRelayService(caller: Address) -> Bool {
        // Implementation would check authorized relay services
        true // Simplified
    }

    // View functions
    @public
    fn getBond(bondId: Bytes32) -> Bond {
        bonds.get(bondId).expect("Bond not found")
    }

    @public
    fn getSenderReputation(senderCommit: Bytes32) -> SenderReputation {
        reputation.get(senderCommit).unwrap_or_default()
    }

    @public
    fn getSafetyPoolBalance(cardId: Bytes32) -> U64 {
        safetyPool.get(cardId).unwrap_or(0)
    }

    @public
    fn getBondConfig(cardId: Bytes32) -> BondConfig {
        cardConfigs.get(cardId).unwrap_or_default()
    }
}
