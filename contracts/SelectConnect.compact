// SPDX-License-Identifier: Apache-2.0

pragma language_version 0.16;

import CompactStandardLibrary;

// ==============================================
// SelectConnect Compact v0.16 example
// --------------------------------
// Purpose:
//  - Privacy-preserving digital business card.
//  - Stores only commitments (hash-like values) on-chain; real data is kept off-chain.
//  - Supports progressive reveal (levels), and per-accessor links you can revoke.
// How to read:
//  - export ledger ...   => on-chain public state (anyone can read)
//  - constructor()       => runs on deploy, initializes counters
//  - witness ...         => private inputs supplied by the caller (not stored publicly)
//  - export circuit ...  => public entry points that verify conditions and update state

// Domain constants (for hashing/commitments)
const DOMAIN_CARD  : Bytes<32> = pad(32, "noircard:card:v1");
const DOMAIN_LINK  : Bytes<32> = pad(32, "noircard:link:v1");
const DOMAIN_LEVEL : Bytes<32> = pad(32, "noircard:level:v1");

// Public types
enum CardState { INACTIVE, ACTIVE }

// Public on-chain state (minimal public metadata)
// round: epoch counter (lets you rotate identities over time if desired)
export ledger round: Counter;                                          // epoch counter
// cards: set of all card IDs that exist
export ledger cards: Set<Bytes<32>>;                                   // cardId
// card_state: stores whether each card is ACTIVE or INACTIVE
export ledger card_state: Map<Bytes<32>, CardState>;                   // cardId -> state
// card_admin: binds a card to an administrator identifier (Bytes<32>) derived from a secret witness
export ledger card_admin: Map<Bytes<32>, Bytes<32>>;                   // cardId -> adminId
// card_policy: public policy metadata (e.g., whether an abuse bond is required, default amounts)
export ledger card_policy: Map<Bytes<32>, (Boolean, Uint<64>, Uint<64>)>; // cardId -> (requiresBond, bondAmount, revealDelay)
// contact_commit: commitment to your contact info ciphertext (actual data held off-chain)
export ledger contact_commit: Map<Bytes<32>, Bytes<32>>;               // cardId -> contactCommitment
// reveal_tree: Merkle tree accumulating commitments for progressive reveal levels
export ledger reveal_tree: MerkleTree<10, Bytes<32>>;                  // commitments of reveal levels
// links: set of generated access link IDs
export ledger links: Set<Bytes<32>>;                                   // linkId
// link_meta: metadata for links: which card, recipient, when created/expires, revoked?, current reveal level index
export ledger link_meta: Map<Bytes<32>, (Bytes<32>, Bytes<32>, Uint<64>, Uint<64>, Boolean, Uint<8>)>; // linkId -> (cardId, link_recipient_id, createdAt, expiresAt, revoked, currentLevel)

// Initialize epoch on deploy
constructor() {
  round.increment(1);
}

// Private inputs (provided by caller/DApp)
witness adminSecret(): Bytes<32>;
witness accessorSecret(): Bytes<32>;
witness rand(): Bytes<32>;

// Helper: derive adminId from epoch-bound secret (rotate with round)
circuit adminId(round: Field, sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([ DOMAIN_CARD, (round as Bytes<32>), sk ]);
}

// Helper: cardId = H(DOMAIN_CARD, adminId, aliasHash)
circuit makeCardId(oid: Bytes<32>, aliasHash: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([ DOMAIN_CARD, oid, aliasHash ]);
}

// Helper: linkId = H(DOMAIN_LINK, cardId, accessorId, createdAt)
circuit makeLinkId(cardId: Bytes<32>, accessorId: Bytes<32>, createdAt: Uint<64>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([
    DOMAIN_LINK, cardId, toBytes32(createdAt)
  ]) ^ accessorId;
}

// Helper: accessorId from epoch and accessor secret
// This function derives an accessorId from the current round and an accessor secret.
circuit accessorId(round: Field, sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<3, Bytes<32>>>([ DOMAIN_LINK, (round as Bytes<32>), sk ]);
}

// Public: create a card (stores only commitments on-chain)
// Inputs:
//  - aliasHash: hash of your chosen alias or handle (public, not PII)
//  - requiresBond/bondAmount/revealDelay: policy knobs for integrations
//  - contactCiphertext: your encrypted contact data (ciphertext), committed on-chain
// Effects:
//  - Derives adminId from your private adminSecret witness
//  - Creates and activates a new card with public policy and contact commitment
export circuit createCard(
  aliasHash: Bytes<32>,
  requiresBond: Bool,
  bondAmount: Uint<64>,
  revealDelay: Uint<64>,
  contactCiphertext: Bytes<32>
): Bytes<32> {
  const sk = adminSecret();
  const aid_admin = adminId(round, sk);
  const cardId = makeCardId(aid_admin, aliasHash);

  assert(!contains(cards, cardId), "card exists");

  insert(cards, cardId);
  insert(card_admin, cardId, aid_admin);
  insert(card_state, cardId, CardState.ACTIVE);
  insert(card_policy, cardId, (requiresBond, bondAmount, revealDelay));

  // Commit contact data
  const r = rand();
  const contactCommitment = persistentCommit<Vector<2, Bytes<32>>>([ contactCiphertext, r ]);
  insert(contact_commit, cardId, contactCommitment);

  return disclose(cardId);
}

// Public: add a reveal level commitment (progressive disclosure)
// Idea:
//  - Each reveal level is a commitment to an encrypted blob.
//  - We append commitments in a Merkle tree so later users can prove inclusion.
export circuit addRevealLevel(cardId: Bytes<32>, levelCiphertext: Bytes<32>): [] {
  assert(contains(cards, cardId), "missing card");
  let cardState = get(card_state, cardId);
  assert(cardState == CardState.ACTIVE, "inactive");

  const lr = rand();
  const levelCommit = persistentCommit<Vector<3, Bytes<32>>>([ DOMAIN_LEVEL, levelCiphertext, lr ]);
  treeInsert(reveal_tree, levelCommit);
}

// Public: generate a link (stores meta, no PII)
// Each accessor presents a witness secret; we derive an accessorId from it and the epoch.
// The link stores only meta (createdAt, expiresAt, revoked flag, and current reveal level index).
export circuit generateLink(cardId: Bytes<32>, createdAt: Uint<64>, ttl: Uint<64>): Bytes<32> {
  assert(contains(cards, cardId), "missing card");
  let cardState = get(card_state, cardId);
  assert(cardState == CardState.ACTIVE, "inactive");

  const ask = accessorSecret();
  const aid = accessorId(round, ask);

  const linkId = makeLinkId(cardId, aid, createdAt);
  const expiresAt = createdAt + ttl;

  insert(links, linkId);
  insert(link_meta, linkId, (cardId, aid, createdAt, expiresAt, false, 0u8));

  return disclose(linkId);
}

// Public: access next level by proving membership of the level commit
// The accessor provides the level ciphertext; we re-commit it and check membership in the Merkle tree.
// On success, we advance the link's currentLevel and return the ciphertext for off-chain decryption.
export circuit accessNextLevel(
  linkId: Bytes<32>,
  nowTs: Uint<64>,
  levelCiphertext: Bytes<32>
): Bytes<32> {
  let (cId, link_recipient_id, createdAt, expiresAt, revoked, currentLevel) = get(link_meta, linkId);
  assert(!revoked, "revoked");
  assert(nowTs < expiresAt, "expired");

  const lr = rand();
  const levelCommit = persistentCommit<Vector<3, Bytes<32>>>([ DOMAIN_LEVEL, levelCiphertext, lr ]);
  assert(treeContains(reveal_tree, levelCommit), "unknown level");

  const nextLevel = currentLevel + 1u8;
  remove(link_meta, linkId);
  insert(link_meta, linkId, (cId, link_recipient_id, createdAt, expiresAt, revoked, nextLevel));

  return disclose(levelCiphertext);
}

// Public: revoke a link (admin-only)
// The admin proves control via adminSecret -> adminId, then marks the link revoked.
export circuit revokeLink(cardId: Bytes<32>, linkId: Bytes<32>): [] {
  const sk = adminSecret();
  const aid_admin = adminId(round, sk);
  let storedAdmin = get(card_admin, cardId);
  assert(storedAdmin == aid_admin, "not admin");

  let (cId, link_recipient_id, createdAt, expiresAt, _revoked, currentLevel) = get(link_meta, linkId);
  assert(cId == cardId, "mismatch");

  remove(link_meta, linkId);
  insert(link_meta, linkId, (cId, link_recipient_id, createdAt, expiresAt, true, currentLevel));
}

// Public: deactivate card (admin-only)
// Flips the card state to INACTIVE to stop future link operations.
export circuit deactivateCard(cardId: Bytes<32>): [] {
  const sk = adminSecret();
  const aid_admin = adminId(round, sk);
  let storedAdmin = get(card_admin, cardId);
  assert(storedAdmin == aid_admin, "not admin");

  remove(card_state, cardId);
  insert(card_state, cardId, CardState.INACTIVE);
}
