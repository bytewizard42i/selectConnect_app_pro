#pragma version "0.16.0"

// AbuseEscrow (Compact-compliant skeleton)
// Replaces unsupported constructs from the previous draft. Models bonds as
// public IDs with metadata in Sets, while sensitive identities are handled
// via commitments. All logic via circuits + asserts + ledger ops.

import Std.Ledger
import Std.Crypto

// -----------------------------
// Public Ledger
// -----------------------------
export ledger bonds: Set<Bytes<32>>                                        // bondId
export ledger bond_meta: Set<(Bytes<32>, Bytes<32>, Bytes<32>, Uint<64>, Uint<64>, Bool, Bool)> // (bondId, cardId, senderCommit, amount, expiresAt, refunded, slashed)
export ledger safety_pool: Set<(Bytes<32>, Uint<64>)>                       // (cardId, balance)
export ledger sender_rep: Set<(Bytes<32>, Uint<32>, Uint<32>, Uint<64>, Uint<64>)> // (senderCommit, totalBonds, slashedCount, lastSlashTime, totalSlashed)
export ledger bond_config: Set<(Bytes<32>, Uint<64>, Uint<64>, Bool, Uint<64>)>    // (cardId, minBondAmount, defaultTTL, dynamicPricing, riskMultiplier)
export ledger card_owner: Set<(Bytes<32>, Bytes<32>)>                        // (cardId, ownerId) authority checks

// -----------------------------
// Helper hashing
// -----------------------------
// bondId = persistentHash(cardId, senderCommit, toBytes32(postedAt))

// -----------------------------
// Circuits
// -----------------------------

export circuit postBond(
  cardId: Bytes<32>,
  senderCommit: Bytes<32>,
  amount: Uint<64>,
  nowTs: Uint<64>,
  ttl: Uint<64>
) -> Bytes<32> {
  // Load config (if any)
  // For simplicity, requiredAmount = minBondAmount with optional dynamic pricing on rep
  let (cfgCard, minBond, defTTL, dynPricing, riskMult) = Ledger.getOrDefault(bond_config, cardId, (cardId, 0u64, 0u64, false, 0u64))
  let requiredAmount = calcRequired(minBond, dynPricing, riskMult, senderCommit)
  assert(amount >= requiredAmount, "insufficient amount")

  // Basic no-dup check (omits exhaustive scan): rely on unique bondId generation
  let expiry = nowTs + (if ttl > 0u64 { ttl } else { defTTL })
  let bondId = persistentHash(cardId, senderCommit, toBytes32(nowTs))

  Ledger.insert(bonds, bondId)
  Ledger.insert(bond_meta, (bondId, cardId, senderCommit, amount, expiry, false, false))

  // Update sender rep
  let (sc, total, slashedCount, lastSlash, totalSlashed) = Ledger.getOrDefault(sender_rep, senderCommit, (senderCommit, 0u32, 0u32, 0u64, 0u64))
  Ledger.remove(sender_rep, senderCommit)
  Ledger.insert(sender_rep, (senderCommit, total + 1u32, slashedCount, lastSlash, totalSlashed))

  bondId
}

export circuit refundBond(
  bondId: Bytes<32>,
  nowTs: Uint<64>,
  authorizerIsOwner: Bool                 // Provided by caller's proof context off-chain
) {
  let (bId, cId, sCommit, amount, expiresAt, refunded, slashed) = Ledger.get(bond_meta, bondId)
  assert(bId == bondId, "not found")
  assert(!refunded && !slashed, "already processed")
  assert(nowTs >= expiresAt || authorizerIsOwner, "not authorized or not expired")

  // Mark refunded
  Ledger.remove(bond_meta, bondId)
  Ledger.insert(bond_meta, (bondId, cId, sCommit, amount, expiresAt, true, slashed))

  // Actual value transfer handled off-chain / runtime integration
}

export circuit slashBond(
  bondId: Bytes<32>,
  cardId: Bytes<32>,
  ownerId: Bytes<32>,
  nowTs: Uint<64>,
  evidenceHash: Bytes<32>
) {
  // Authorization: owner of card
  assert(Ledger.contains(card_owner, (cardId, ownerId)), "not owner")

  let (bId, cId, sCommit, amount, expiresAt, refunded, slashed) = Ledger.get(bond_meta, bondId)
  assert(bId == bondId && cId == cardId, "bond/card mismatch")
  assert(!refunded && !slashed, "already processed")

  // Mark slashed
  Ledger.remove(bond_meta, bondId)
  Ledger.insert(bond_meta, (bondId, cId, sCommit, amount, expiresAt, refunded, true))

  // Update sender reputation
  let (sc, total, slashedCount, lastSlash, totalSlashed) = Ledger.getOrDefault(sender_rep, sCommit, (sCommit, 0u32, 0u32, 0u64, 0u64))
  Ledger.remove(sender_rep, sCommit)
  Ledger.insert(sender_rep, (sCommit, total, slashedCount + 1u32, nowTs, totalSlashed + amount))

  // Split: add half to safety pool; burning modeled off-ledger
  let half = amount / 2u64
  let (poolCard, bal) = Ledger.getOrDefault(safety_pool, cardId, (cardId, 0u64))
  Ledger.remove(safety_pool, cardId)
  Ledger.insert(safety_pool, (cardId, bal + half))
}

export circuit configureBond(
  cardId: Bytes<32>,
  ownerId: Bytes<32>,
  minBondAmount: Uint<64>,
  defaultTTL: Uint<64>,
  dynamicPricing: Bool,
  riskMultiplier: Uint<64>
) {
  assert(Ledger.contains(card_owner, (cardId, ownerId)), "not owner")
  // Replace tuple by removing and inserting
  if (Ledger.contains(bond_config, cardId)) {
    Ledger.remove(bond_config, cardId)
  }
  Ledger.insert(bond_config, (cardId, minBondAmount, defaultTTL, dynamicPricing, riskMultiplier))
}

// -----------------------------
// Helpers
// -----------------------------
fn calcRequired(minBond: Uint<64>, dynPricing: Bool, riskMult: Uint<64>, senderCommit: Bytes<32>) -> Uint<64> {
  if (!dynPricing) { return minBond }
  let (sc, total, slashedCount, _lastSlash, _totalSlashed) = Ledger.getOrDefault(sender_rep, senderCommit, (senderCommit, 0u32, 0u32, 0u64, 0u64))
  if (slashedCount == 0u32) { return minBond }
  // Increase linearly by riskMult per past slash (basis-points-like). Simplified.
  let multiplierBp = 10000u64 + (toUint64(slashedCount) * riskMult)
  (minBond * multiplierBp) / 10000u64
}
