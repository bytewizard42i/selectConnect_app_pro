// Compact v0.16.0 - Privacy-preserving NoirCard contract
// Compatible with Midnight blockchain
compact 0.16.0;

/**
 * NoirCard - Privacy-first business card system with progressive reveal
 * 
 * This contract enables users to create digital business cards that can be shared
 * via QR codes with privacy-preserving features including:
 * - Progressive contact information disclosure
 * - Revocable access links with time-based expiration
 * - Abuse protection through economic bonds
 * - Pseudonymous tracking for safety without compromising privacy
 */
circuit NoirCard {
    // State variables for contract storage
    state cards: Map<Bytes32, Card>;
    state cardRevealLevels: Map<Bytes32, Array<RevealLevel>>;
    state accessLinks: Map<Bytes32, AccessLink>;
    state ownerCards: Map<Address, Array<Bytes32>>;
    state cardLinks: Map<Bytes32, Array<Bytes32>>;
    
    /**
     * Core structure representing a NoirCard business card
     * Each card contains encrypted contact data that can be progressively revealed
     */
    struct Card {
        cardId: Bytes32,           // Unique identifier for this business card
        owner: Address,            // Owner's address
        alias: String,             // Public display name (e.g., "John Doe - Tech Conference")
        contactDataHash: Bytes32,  // Cryptographic hash of encrypted contact information
        active: Bool,              // Whether the card is currently active and accessible
        createdAt: U64,            // Unix timestamp when card was created
        expiresAt: U64,            // Unix timestamp when card expires (0 = never expires)
        policy: CardPolicy,        // Configuration for how this card can be accessed
    }

    /**
     * Policy configuration that controls how a NoirCard can be accessed
     * These settings determine security, privacy, and interaction rules
     */
    struct CardPolicy {
        requiresBond: Bool,        // True if senders must post economic bond to contact owner
        bondAmount: U64,           // Amount of ADA required as anti-spam bond (in lovelace)
        revealDelay: U64,          // Minimum seconds between progressive reveal levels
        linkTTL: U64,              // How long access links remain valid (seconds)
        allowRevocation: Bool,     // Whether owner can instantly revoke access links
        maxReveals: U8,            // Maximum reveal levels (typically 1-5)
        venueRestriction: Bytes32, // Optional: restrict usage to specific venue/event
    }

    /**
     * Defines a single level in the progressive contact reveal system
     * Each level contains increasingly sensitive information
     * Example progression: Level 1 (name) → Level 2 (email) → Level 3 (phone)
     */
    struct RevealLevel {
        level: U8,                 // Sequential reveal level (1=basic, 2=contact, 3=detailed, etc.)
        dataType: String,          // Type of data: "name", "email", "phone", "social", "full"
        encryptedData: Bytes32,    // Encrypted contact information for this specific level
        requiresApproval: Bool,    // True if owner must manually approve access to this level
    }

    /**
     * Represents a time-limited, revocable access link to a NoirCard
     * These links are embedded in QR codes and can be shared at events
     * Each link tracks usage and can be instantly revoked for safety
     */
    struct AccessLink {
        linkId: Bytes32,           // Cryptographically unique identifier for this access link
        cardId: Bytes32,           // Which NoirCard this link provides access to
        accessor: Address,         // Address of person who accessed (zero if anonymous)
        accessorCommit: Bytes32,   // Privacy-preserving commitment identifying the accessor
        createdAt: U64,            // Unix timestamp when link was generated
        expiresAt: U64,            // Unix timestamp when link expires and becomes invalid
        lastAccessed: U64,         // Unix timestamp of most recent access attempt
        revoked: Bool,             // True if owner has revoked this link (instant cutoff)
        currentLevel: U8,          // Highest reveal level this link has accessed so far
    }

    /**
     * CONTRACT STORAGE
     * These mappings store all the contract's persistent data on the blockchain
     */
    

    /**
     * CIRCUIT EVENTS
     * These events are emitted to create an immutable audit trail
     * External applications can listen to these events for real-time updates
     */
    
    // Card lifecycle events
    event CardCreated { cardId: Bytes32, owner: Address, alias: String }
    event CardUpdated { cardId: Bytes32, newContactDataHash: Bytes32 }
    event CardRevoked { cardId: Bytes32, owner: Address }
    
    // Access link events
    event LinkGenerated { linkId: Bytes32, cardId: Bytes32, expiresAt: U64 }
    event LinkAccessed { linkId: Bytes32, cardId: Bytes32, revealLevel: U8 }
    event LinkRevoked { linkId: Bytes32, cardId: Bytes32 }
    
    // Privacy events
    event ContactRevealed { cardId: Bytes32, linkId: Bytes32, level: U8 }

    /**
     * CREATE A NEW NOIRCARD
     * 
     * This function allows users to create a new privacy-preserving business card
     * The card will be assigned a unique ID and stored on the blockchain
     */
    @public
    fn createCard(
        alias: String,
        contactDataHash: Bytes32,
        policy: CardPolicy,
        revealLevels: Array<RevealLevel>
    ) -> Bytes32 {
        // Generate cryptographically unique card ID using sender address, alias, and timestamp
        let cardId = hash(context.sender, alias, context.block_time);
        
        assert(!cards.contains_key(cardId), "Card already exists");
        assert(alias.len() > 0, "Alias required");
        assert(revealLevels.len() > 0, "At least one reveal level required");

        // Create card
        let card = Card {
            cardId: cardId,
            owner: context.sender,
            alias: alias,
            contactDataHash: contactDataHash,
            active: true,
            createdAt: context.block_time,
            expiresAt: if policy.linkTTL > 0 { context.block_time + policy.linkTTL } else { 0 },
            policy: policy,
        };
        
        cards.insert(cardId, card);
        cardRevealLevels.insert(cardId, revealLevels);
        
        // Add to owner's cards
        let mut owner_cards = ownerCards.get(context.sender).unwrap_or_default();
        owner_cards.push(cardId);
        ownerCards.insert(context.sender, owner_cards);

        emit CardCreated { cardId, owner: context.sender, alias };
        cardId
    }

    // Generate access link for QR code
    @public
    fn generateAccessLink(
        cardId: Bytes32,
        customTTL: U64,
        accessorCommit: Bytes32
    ) -> Bytes32 {
        let card = cards.get(cardId).expect("Card not found");
        assert!(card.active, "Card not active");
        assert!(card.owner == context.sender, "Not card owner");
        
        // Check card hasn't expired
        if card.expiresAt > 0 {
            assert!(context.block_time < card.expiresAt, "Card expired");
        }

        // Generate unique link ID
        let linkId = hash(cardId, accessorCommit, context.block_time);
        
        // Determine expiration
        let linkExpiry = if customTTL > 0 {
            context.block_time + customTTL
        } else {
            context.block_time + card.policy.linkTTL
        };

        // Create access link
        let link = AccessLink {
            linkId: linkId,
            cardId: cardId,
            accessor: Address::zero(), // Anonymous initially
            accessorCommit: accessorCommit,
            createdAt: context.block_time,
            expiresAt: linkExpiry,
            lastAccessed: 0,
            revoked: false,
            currentLevel: 0,
        };
        
        accessLinks.insert(linkId, link);

        // Track link for card
        let mut card_links = cardLinks.get(cardId).unwrap_or_default();
        card_links.push(linkId);
        cardLinks.insert(cardId, card_links);

        emit LinkGenerated { linkId, cardId, expiresAt: linkExpiry };
        linkId
    }

    // Access card via link (progressive reveal)
    @public
    fn accessCard(
        linkId: Bytes32,
        requestedLevel: U8,
        accessorCommit: Bytes32
    ) -> Bytes32 {
        let mut link = accessLinks.get(linkId).expect("Link not found");
        let card = cards.get(link.cardId).expect("Card not found");
        
        assert!(!link.revoked, "Link revoked");
        assert!(context.block_time < link.expiresAt, "Link expired");
        assert!(card.active, "Card not active");
        assert!(link.accessorCommit == accessorCommit, "Invalid accessor");

        // Check if requested level is available
        let reveal_levels = cardRevealLevels.get(link.cardId).expect("No reveal levels");
        assert!(requestedLevel > 0 && requestedLevel <= reveal_levels.len() as U8, "Invalid reveal level");
        
        // Progressive reveal: can only access next level
        assert!(requestedLevel <= link.currentLevel + 1, "Must progress sequentially");

        // Check reveal delay for progressive disclosure
        if link.currentLevel > 0 && card.policy.revealDelay > 0 {
            assert!(
                context.block_time >= link.lastAccessed + card.policy.revealDelay,
                "Reveal delay not met"
            );
        }

        // Get reveal level data
        let reveal_level = &reveal_levels[(requestedLevel - 1) as usize];
        
        // Check if owner approval is required for this level
        if reveal_level.requiresApproval && requestedLevel > link.currentLevel {
            // In a real implementation, this would trigger an approval workflow
            // For now, we'll assume approval is granted
        }

        // Update link state
        link.currentLevel = requestedLevel;
        link.lastAccessed = context.block_time;
        if link.accessor == Address::zero() {
            link.accessor = context.sender;
        }
        
        accessLinks.insert(linkId, link);

        emit LinkAccessed { linkId, cardId: link.cardId, revealLevel: requestedLevel };
        emit ContactRevealed { cardId: link.cardId, linkId, level: requestedLevel };

        reveal_level.encryptedData
    }

    // Revoke access link
    @public
    fn revokeLink(linkId: Bytes32) {
        let mut link = accessLinks.get(linkId).expect("Link not found");
        let card = cards.get(link.cardId).expect("Card not found");
        
        assert!(card.owner == context.sender, "Not authorized");
        assert!(card.policy.allowRevocation, "Revocation not allowed");
        assert!(!link.revoked, "Already revoked");

        link.revoked = true;
        accessLinks.insert(linkId, link);
        
        emit LinkRevoked { linkId, cardId: link.cardId };
    }

    // Update card contact data
    @public
    fn updateCard(
        cardId: Bytes32,
        newContactDataHash: Bytes32,
        newRevealLevels: Array<RevealLevel>
    ) {
        let mut card = cards.get(cardId).expect("Card not found");
        assert!(card.owner == context.sender, "Not card owner");
        assert!(card.active, "Card not active");

        card.contactDataHash = newContactDataHash;
        cards.insert(cardId, card);
        
        // Update reveal levels
        cardRevealLevels.insert(cardId, newRevealLevels);

        emit CardUpdated { cardId, newContactDataHash };
    }

    // Deactivate card
    @public
    fn revokeCard(cardId: Bytes32) {
        let mut card = cards.get(cardId).expect("Card not found");
        assert!(card.owner == context.sender, "Not card owner");
        assert!(card.active, "Card already inactive");

        card.active = false;
        cards.insert(cardId, card);
        
        // Revoke all active links
        let links = cardLinks.get(cardId).unwrap_or_default();
        for linkId in links {
            let mut link = accessLinks.get(linkId).expect("Link not found");
            if !link.revoked {
                link.revoked = true;
                accessLinks.insert(linkId, link);
                emit LinkRevoked { linkId, cardId };
            }
        }

        emit CardRevoked { cardId, owner: context.sender };
    }

    // View functions
    @public
    fn getCard(cardId: Bytes32) -> Card {
        cards.get(cardId).expect("Card not found")
    }

    @public
    fn getAccessLink(linkId: Bytes32) -> AccessLink {
        accessLinks.get(linkId).expect("Link not found")
    }

    @public
    fn getCardRevealLevels(cardId: Bytes32) -> Array<RevealLevel> {
        cardRevealLevels.get(cardId).expect("No reveal levels found")
    }

    @public
    fn getOwnerCards(owner: Address) -> Array<Bytes32> {
        ownerCards.get(owner).unwrap_or_default()
    }

    @public
    fn getCardLinks(cardId: Bytes32) -> Array<Bytes32> {
        cardLinks.get(cardId).unwrap_or_default()
    }

    // Check if card requires abuse bond
    @public
    fn requiresBond(cardId: Bytes32) -> (Bool, U64) {
        let card = cards.get(cardId).expect("Card not found");
        (card.policy.requiresBond, card.policy.bondAmount)
    }
}
