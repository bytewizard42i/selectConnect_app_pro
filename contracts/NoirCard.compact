// Compact language version - using latest stable version
// For compatibility with Midnight network as of 2025
pragma language_version >= 0.16.0;

/**
 * NoirCard - Privacy-first business card system with progressive reveal
 * 
 * This contract enables users to create digital business cards that can be shared
 * via QR codes with privacy-preserving features including:
 * - Progressive contact information disclosure
 * - Revocable access links with time-based expiration
 * - Abuse protection through economic bonds
 * - Pseudonymous tracking for safety without compromising privacy
 */
contract NoirCard {
    
    /**
     * Core structure representing a NoirCard business card
     * Each card contains encrypted contact data that can be progressively revealed
     */
    struct Card {
        bytes32 cardId;           // Unique identifier for this business card
        address owner;            // Ethereum address of the card owner
        string  alias;            // Public display name (e.g., "John Doe - Tech Conference")
        bytes32 contactDataHash;  // Cryptographic hash of encrypted contact information
        bool    active;           // Whether the card is currently active and accessible
        uint64  createdAt;        // Unix timestamp when card was created
        uint64  expiresAt;        // Unix timestamp when card expires (0 = never expires)
        CardPolicy policy;        // Configuration for how this card can be accessed
    }

    /**
     * Policy configuration that controls how a NoirCard can be accessed
     * These settings determine security, privacy, and interaction rules
     */
    struct CardPolicy {
        bool    requiresBond;     // True if senders must post economic bond to contact owner
        coin    bondAmount;       // Amount of ADA required as anti-spam bond (in lovelace)
        uint64  revealDelay;      // Minimum seconds between progressive reveal levels
        uint64  linkTTL;          // How long access links remain valid (seconds)
        bool    allowRevocation;  // Whether owner can instantly revoke access links
        uint8   maxReveals;       // Maximum reveal levels (typically 1-5)
        bytes32 venueRestriction; // Optional: restrict usage to specific venue/event
    }

    /**
     * Defines a single level in the progressive contact reveal system
     * Each level contains increasingly sensitive information
     * Example progression: Level 1 (name) → Level 2 (email) → Level 3 (phone)
     */
    struct RevealLevel {
        uint8   level;            // Sequential reveal level (1=basic, 2=contact, 3=detailed, etc.)
        string  dataType;         // Type of data: "name", "email", "phone", "social", "full"
        bytes32 encryptedData;    // Encrypted contact information for this specific level
        bool    requiresApproval; // True if owner must manually approve access to this level
    }

    /**
     * Represents a time-limited, revocable access link to a NoirCard
     * These links are embedded in QR codes and can be shared at events
     * Each link tracks usage and can be instantly revoked for safety
     */
    struct AccessLink {
        bytes32 linkId;           // Cryptographically unique identifier for this access link
        bytes32 cardId;           // Which NoirCard this link provides access to
        address accessor;         // Ethereum address of person who accessed (zero if anonymous)
        bytes32 accessorCommit;   // Privacy-preserving commitment identifying the accessor
        uint64  createdAt;        // Unix timestamp when link was generated
        uint64  expiresAt;        // Unix timestamp when link expires and becomes invalid
        uint64  lastAccessed;     // Unix timestamp of most recent access attempt
        bool    revoked;          // True if owner has revoked this link (instant cutoff)
        uint8   currentLevel;     // Highest reveal level this link has accessed so far
    }

    /**
     * CONTRACT STORAGE
     * These mappings store all the contract's persistent data on the blockchain
     */
    
    // Core data storage
    mapping(bytes32 => Card) cards;                           // Maps cardId to Card struct
    mapping(bytes32 => RevealLevel[]) cardRevealLevels;       // Maps cardId to array of reveal levels
    mapping(bytes32 => AccessLink) accessLinks;              // Maps linkId to AccessLink struct
    
    // Index mappings for efficient queries
    mapping(address => bytes32[]) ownerCards;                 // Maps owner address to their cardIds
    mapping(bytes32 => bytes32[]) cardLinks;                  // Maps cardId to all its linkIds

    /**
     * BLOCKCHAIN EVENTS
     * These events are emitted to create an immutable audit trail
     * External applications can listen to these events for real-time updates
     */
    
    // Card lifecycle events
    event CardCreated(bytes32 indexed cardId, address indexed owner, string alias);
    event CardUpdated(bytes32 indexed cardId, bytes32 newContactDataHash);
    event CardRevoked(bytes32 indexed cardId, address indexed owner);
    
    // Access link events
    event LinkGenerated(bytes32 indexed linkId, bytes32 indexed cardId, uint64 expiresAt);
    event LinkAccessed(bytes32 indexed linkId, bytes32 indexed cardId, uint8 revealLevel);
    event LinkRevoked(bytes32 indexed linkId, bytes32 indexed cardId);
    
    // Privacy events
    event ContactRevealed(bytes32 indexed cardId, bytes32 indexed linkId, uint8 level);

    /**
     * CREATE A NEW NOIRCARD
     * 
     * This function allows users to create a new privacy-preserving business card
     * The card will be assigned a unique ID and stored on the blockchain
     * 
     * @param alias Human-readable name for the card (e.g., "John Doe - DevCon 2025")
     * @param contactDataHash Cryptographic hash of encrypted contact information
     * @param policy Access rules and security settings for this card
     * @param revealLevels Array defining progressive disclosure levels
     * @return cardId Unique identifier for the newly created card
     */
    function createCard(
        string memory alias,
        bytes32 contactDataHash,
        CardPolicy memory policy,
        RevealLevel[] memory revealLevels
    ) public returns (bytes32 cardId) {
        // Generate cryptographically unique card ID using sender address, alias, and timestamp
        cardId = keccak256(abi.encodePacked(msg.sender, alias, block.timestamp));
        
        require(cards[cardId].owner == address(0), "Card already exists");
        require(bytes(alias).length > 0, "Alias required");
        require(revealLevels.length > 0, "At least one reveal level required");

        // Create card
        cards[cardId] = Card({
            cardId: cardId,
            owner: msg.sender,
            alias: alias,
            contactDataHash: contactDataHash,
            active: true,
            createdAt: uint64(block.timestamp),
            expiresAt: policy.linkTTL > 0 ? uint64(block.timestamp + policy.linkTTL) : 0,
            policy: policy
        });

        // Store reveal levels
        for (uint i = 0; i < revealLevels.length; i++) {
            cardRevealLevels[cardId].push(revealLevels[i]);
        }

        // Add to owner's cards
        ownerCards[msg.sender].push(cardId);

        emit CardCreated(cardId, msg.sender, alias);
        return cardId;
    }

    // Generate access link for QR code
    function generateAccessLink(
        bytes32 cardId,
        uint64 customTTL,
        bytes32 accessorCommit
    ) public returns (bytes32 linkId) {
        Card storage card = cards[cardId];
        require(card.active, "Card not active");
        require(card.owner == msg.sender, "Not card owner");
        
        // Check card hasn't expired
        if (card.expiresAt > 0) {
            require(block.timestamp < card.expiresAt, "Card expired");
        }

        // Generate unique link ID
        linkId = keccak256(abi.encodePacked(cardId, accessorCommit, block.timestamp));
        
        // Determine expiration
        uint64 linkExpiry = customTTL > 0 ? 
            uint64(block.timestamp + customTTL) : 
            uint64(block.timestamp + card.policy.linkTTL);

        // Create access link
        accessLinks[linkId] = AccessLink({
            linkId: linkId,
            cardId: cardId,
            accessor: address(0), // Anonymous initially
            accessorCommit: accessorCommit,
            createdAt: uint64(block.timestamp),
            expiresAt: linkExpiry,
            lastAccessed: 0,
            revoked: false,
            currentLevel: 0
        });

        // Track link for card
        cardLinks[cardId].push(linkId);

        emit LinkGenerated(linkId, cardId, linkExpiry);
        return linkId;
    }

    // Access card via link (progressive reveal)
    function accessCard(
        bytes32 linkId,
        uint8 requestedLevel,
        bytes32 accessorCommit
    ) public returns (bytes32 revealedData) {
        AccessLink storage link = accessLinks[linkId];
        Card storage card = cards[link.cardId];
        
        require(link.linkId != bytes32(0), "Link not found");
        require(!link.revoked, "Link revoked");
        require(block.timestamp < link.expiresAt, "Link expired");
        require(card.active, "Card not active");
        require(link.accessorCommit == accessorCommit, "Invalid accessor");

        // Check if requested level is available
        require(requestedLevel > 0 && requestedLevel <= cardRevealLevels[link.cardId].length, "Invalid reveal level");
        
        // Progressive reveal: can only access next level
        require(requestedLevel <= link.currentLevel + 1, "Must progress sequentially");

        // Check reveal delay for progressive disclosure
        if (link.currentLevel > 0 && card.policy.revealDelay > 0) {
            require(
                block.timestamp >= link.lastAccessed + card.policy.revealDelay,
                "Reveal delay not met"
            );
        }

        // Get reveal level data
        RevealLevel storage revealLevel = cardRevealLevels[link.cardId][requestedLevel - 1];
        
        // Check if owner approval is required for this level
        if (revealLevel.requiresApproval && requestedLevel > link.currentLevel) {
            // In a real implementation, this would trigger an approval workflow
            // For now, we'll assume approval is granted
        }

        // Update link state
        link.currentLevel = requestedLevel;
        link.lastAccessed = uint64(block.timestamp);
        if (link.accessor == address(0)) {
            link.accessor = msg.sender;
        }

        emit LinkAccessed(linkId, link.cardId, requestedLevel);
        emit ContactRevealed(link.cardId, linkId, requestedLevel);

        return revealLevel.encryptedData;
    }

    // Revoke access link
    function revokeLink(bytes32 linkId) public {
        AccessLink storage link = accessLinks[linkId];
        Card storage card = cards[link.cardId];
        
        require(link.linkId != bytes32(0), "Link not found");
        require(card.owner == msg.sender, "Not authorized");
        require(card.policy.allowRevocation, "Revocation not allowed");
        require(!link.revoked, "Already revoked");

        link.revoked = true;
        
        emit LinkRevoked(linkId, link.cardId);
    }

    // Update card contact data
    function updateCard(
        bytes32 cardId,
        bytes32 newContactDataHash,
        RevealLevel[] memory newRevealLevels
    ) public {
        Card storage card = cards[cardId];
        require(card.owner == msg.sender, "Not card owner");
        require(card.active, "Card not active");

        card.contactDataHash = newContactDataHash;
        
        // Clear old reveal levels
        delete cardRevealLevels[cardId];
        
        // Add new reveal levels
        for (uint i = 0; i < newRevealLevels.length; i++) {
            cardRevealLevels[cardId].push(newRevealLevels[i]);
        }

        emit CardUpdated(cardId, newContactDataHash);
    }

    // Deactivate card
    function revokeCard(bytes32 cardId) public {
        Card storage card = cards[cardId];
        require(card.owner == msg.sender, "Not card owner");
        require(card.active, "Card already inactive");

        card.active = false;
        
        // Revoke all active links
        bytes32[] storage links = cardLinks[cardId];
        for (uint i = 0; i < links.length; i++) {
            if (!accessLinks[links[i]].revoked) {
                accessLinks[links[i]].revoked = true;
                emit LinkRevoked(links[i], cardId);
            }
        }

        emit CardRevoked(cardId, msg.sender);
    }

    // View functions
    function getCard(bytes32 cardId) public view returns (Card memory) {
        return cards[cardId];
    }

    function getAccessLink(bytes32 linkId) public view returns (AccessLink memory) {
        return accessLinks[linkId];
    }

    function getCardRevealLevels(bytes32 cardId) public view returns (RevealLevel[] memory) {
        return cardRevealLevels[cardId];
    }

    function getOwnerCards(address owner) public view returns (bytes32[] memory) {
        return ownerCards[owner];
    }

    function getCardLinks(bytes32 cardId) public view returns (bytes32[] memory) {
        return cardLinks[cardId];
    }

    // Check if card requires abuse bond
    function requiresBond(bytes32 cardId) public view returns (bool, coin) {
        Card storage card = cards[cardId];
        return (card.policy.requiresBond, card.policy.bondAmount);
    }
}
